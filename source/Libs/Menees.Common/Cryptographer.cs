namespace Menees
{
	#region Using Directives

	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.IO;
	using System.Linq;
	using System.Security.Cryptography;
	using System.Text;

	#endregion

	/// <summary>
	/// Provides methods for encryption and decryption.
	/// </summary>
	public static class Cryptographer
	{
		#region Private Data Members

		/*
		* NOTE: The default bytes were generated by www.random.org.   The randomness comes from atmospheric
		* noise, which for many purposes is better than the pseudo-random number algorithms typically used in programs.
		*/

		// This is the encryption key used with EncryptionScope.Global.  The bit size of this array
		// must match the KeySize of the encryption algorithm we use.
		private static readonly byte[] globalKey = !string.IsNullOrEmpty(Properties.Settings.Default.CryptographerGlobalKey)
			? ConvertUtility.FromHexString(Properties.Settings.Default.CryptographerGlobalKey)
			: new byte[]
			{
				97, 83, 45, 172, 171, 51, 222, 149, 128, 148, 109, 203, 138, 247, 133, 245,
				255, 216, 76, 159, 4, 36, 26, 132, 204, 199, 169, 113, 228, 202, 88, 232
			};

		// See .NET's help for the SymmetricAlgorithm.IV property for a good explanation
		// of what initialization vectors are used for.  The bit size of this array must match
		// the BlockSize of the encryption algorithm we use.
		private static readonly byte[] initializationVector = !string.IsNullOrEmpty(Properties.Settings.Default.CryptographerInitializationVector)
			? ConvertUtility.FromHexString(Properties.Settings.Default.CryptographerInitializationVector)
			: new byte[]
			{
				134, 67, 212, 195, 213, 244, 94, 175, 183, 37, 192, 129, 112, 234, 33, 211
			};

		// This is used as entropy for the Data Protection API methods.
		private static readonly byte[] dataProtectionEntropy = !string.IsNullOrEmpty(Properties.Settings.Default.CryptographerDataProtectionEntropy)
			? ConvertUtility.FromHexString(Properties.Settings.Default.CryptographerDataProtectionEntropy)
			: new byte[]
			{
				80, 164, 108, 50, 181, 106, 177, 1, 30, 224, 156, 123, 229, 158, 147, 187,
				47, 110, 58, 190, 214, 235, 210, 96, 27, 165, 12, 231, 240, 32, 92, 248
			};

		#endregion

		#region Public String Symmetric Encryption Methods

		/// <summary>
		/// Encrypts text data using the Global <see cref="EncryptionScope"/>.
		/// </summary>
		/// <param name="plaintext">The data to encrypt.</param>
		/// <returns>The encrypted data.</returns>
		public static string Encrypt(string plaintext)
		{
			return Encrypt(plaintext, EncryptionScope.Global);
		}

		/// <summary>
		/// Encrypts text data using the specified encryption scope.
		/// </summary>
		/// <param name="plaintext">The data to encrypt.</param>
		/// <param name="scope">The encryption scope (user-level, machine-level, or global).</param>
		/// <returns>The encrypted data.</returns>
		public static string Encrypt(string plaintext, EncryptionScope scope)
		{
			// It's ok if plaintext is empty (or null, which we'll treat as empty).
			//
			// Note: Decrypt will use this same Encoding.
			byte[] plainBytes = Encoding.UTF8.GetBytes(plaintext ?? string.Empty);
			byte[] encryptedBytes = Encrypt(plainBytes, scope);
			string result = Convert.ToBase64String(encryptedBytes);
			return result;
		}

		/// <summary>
		/// Decrypts text data using the Global <see cref="EncryptionScope"/>.
		/// </summary>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <returns>The decrypted data.</returns>
		public static string Decrypt(string encryptedData)
		{
			return Decrypt(encryptedData, EncryptionScope.Global);
		}

		/// <summary>
		/// Decrypts text data using the specified encryption scope.
		/// </summary>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <param name="scope">The encryption scope (user-level, machine-level, or global).</param>
		/// <returns>The decrypted data.</returns>
		public static string Decrypt(string encryptedData, EncryptionScope scope)
		{
			string result;

			if (string.IsNullOrEmpty(encryptedData))
			{
				// None of the supported encryption algorithms will ever return an empty
				// string, so we know the data is invalid.  However, an empty string may
				// be passed in as a default value (e.g., Decrypt(config.GetValue("Password", ""))),
				// so it's probably safer to just return an empty string instead of throwing.
				result = string.Empty;
			}
			else
			{
				byte[] encryptedBytes = Convert.FromBase64String(encryptedData ?? string.Empty);
				byte[] decryptedBytes = Decrypt(encryptedBytes, scope);

				// This has to match the Encoding used in Encrypt.
				result = Encoding.UTF8.GetString(decryptedBytes);
			}

			return result;
		}

		#endregion

		#region Public Byte[] Symmetric Encryption Methods

		/// <summary>
		/// Encrypts binary data using the Global <see cref="EncryptionScope"/>.
		/// </summary>
		/// <param name="plainData">The data to encrypt.</param>
		/// <returns>The encrypted data.</returns>
		public static byte[] Encrypt(byte[] plainData)
		{
			return Encrypt(plainData, EncryptionScope.Global);
		}

		/// <summary>
		/// Encrypts binary data using the specified encryption scope.
		/// </summary>
		/// <param name="plainData">The data to encrypt.</param>
		/// <param name="scope">The encryption scope (user-level, machine-level, or global).</param>
		/// <returns>The encrypted data.</returns>
		public static byte[] Encrypt(byte[] plainData, EncryptionScope scope)
		{
			Conditions.RequireReference(plainData, "plainData");

			byte[] result;

			DataProtectionScope protectDataScope;
			if (GetDataProtectionScope(scope, out protectDataScope))
			{
				result = ProtectedData.Protect(plainData, dataProtectionEntropy, protectDataScope);
			}
			else
			{
				using (SymmetricAlgorithm sym = CreateSymmetricAlgorithm())
				using (ICryptoTransform transform = sym.CreateEncryptor())
				using (MemoryStream memoryStream = new MemoryStream())
				{
					using (CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Write))
					{
						cryptoStream.Write(plainData, 0, plainData.Length);
					}

					result = memoryStream.ToArray();
				}
			}

			return result;
		}

		/// <summary>
		/// Decrypts binary data using the Global <see cref="EncryptionScope"/>.
		/// </summary>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <returns>The decrypted data.</returns>
		public static byte[] Decrypt(byte[] encryptedData)
		{
			return Decrypt(encryptedData, EncryptionScope.Global);
		}

		/// <summary>
		/// Decrypts binary data using the specified encryption scope.
		/// </summary>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <param name="scope">The encryption scope (user-level, machine-level, or global).</param>
		/// <returns>The decrypted data.</returns>
		public static byte[] Decrypt(byte[] encryptedData, EncryptionScope scope)
		{
			Conditions.RequireReference(encryptedData, "encryptedData");

			byte[] result;

			DataProtectionScope protectDataScope;
			if (GetDataProtectionScope(scope, out protectDataScope))
			{
				result = ProtectedData.Unprotect(encryptedData, dataProtectionEntropy, protectDataScope);
			}
			else
			{
				using (SymmetricAlgorithm sym = CreateSymmetricAlgorithm())
				using (ICryptoTransform transform = sym.CreateDecryptor())
				using (MemoryStream memoryStream = new MemoryStream(encryptedData))
				{
					using (CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Read))
					{
						// We can't determine the exact final size of the plain data yet,
						// but we know it can never be longer than the encrypted data.
						byte[] plainDataBuffer = new byte[encryptedData.Length];

						// Decrypt the bytes.  The return value tells us the actual length of the plain data.
						int plainDataLength = cryptoStream.Read(plainDataBuffer, 0, plainDataBuffer.Length);

						// Shrink the buffer down to the correct plain data length.
						Array.Resize(ref plainDataBuffer, plainDataLength);
						result = plainDataBuffer;
					}
				}
			}

			return result;
		}

		#endregion

		#region Private Methods

		private static bool GetDataProtectionScope(EncryptionScope scope, out DataProtectionScope protectDataScope)
		{
			bool result = false;
			protectDataScope = default(DataProtectionScope);

			switch (scope)
			{
				case EncryptionScope.LocalMachine:
					protectDataScope = DataProtectionScope.LocalMachine;
					result = true;
					break;

				case EncryptionScope.CurrentUser:
					protectDataScope = DataProtectionScope.CurrentUser;
					result = true;
					break;
			}

			return result;
		}

		private static SymmetricAlgorithm CreateSymmetricAlgorithm()
		{
			// This is the only place we specifically refer to an encryption algorithm. We could just call SymmetricAlgorithm.Create()
			// to let .NET create its default algorithm (which is RijndaelManaged in .NET 4).  However, we don't want this algorithm
			// to change with new versions of .NET because we'll have stored values that depend upon it.  Also, AesManaged exists
			// in all .NET flavors (even Silverlight), but RijndaelManaged doesn't.  AesManaged is just as strong as RijndaelManaged
			// because AesManaged just wraps RijndaelManaged in the Windows version of .NET 4.  But AesManaged is the more
			// portable identifier, so I went with it here.
			SymmetricAlgorithm result = new AesManaged();

			Debug.Assert(result.KeySize == globalKey.Length * 8, "The encryption key sizes must match.");
			result.Key = globalKey;

			Debug.Assert(result.BlockSize == initializationVector.Length * 8, "The initialization vector size must match the block size.");
			result.IV = initializationVector;

			return result;
		}

		#endregion
	}
}
